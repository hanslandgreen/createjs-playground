/*
 * @class FileLoader
 *  
 * This class is a jQuery wrapper around the createjs.PreloadJS class. It is intended as a "one-shot" files loader: each
 * instance is expected to be used for one file (or batch of files) only.
 * 
 * Loading Files
 * =============
 * 
 * The files to load are specified through a "manifest" object as the constructor first argument; the manifest can be 
 * one of the following:
 *      + A single file path given as a String:
 *      
 *          new playground.FileLoader("assets/myfile.txt");
 *
 *  
 *      + A single file given as a literal javascript object:
 *      
 *            new playground.FileLoader({ src: "assets/myfile.txt" });
 *
 * 
 *      + A batch of files as an Array of String objects:
 *      
 *            new playground.FileLoader(["assets/myfile.txt", "assets/images/1.png"]);
 *            
 *      
 *      + A batch of files as an Array of literal javascript objects:
 *      
 *            new playground.FileLoader([{ src: "assets/myfile.txt" }, { src: "assets/images/1.png" }]);
 *            
 *            
 * Note that as a second argument to the constructor, you can specify the maximum number of concurrent downloads. The
 * default value is 1. 
 *            
 * When giving file paths as String objects only, each file will be given this path as its ID value (see callbacks and
 * the 'fileID' property below).  
 * When using literal javascript objects, you can use several properties as described below:
 *
 *     {
 *         src:  <MANDATORY — File path to load>,
 *         id:   <File ID to use in place of src value>,
 *         type: <Type string (see below) to override PreloadJS guessing>,
 *         data: <Arbitrary data passed along unmodified in the file completion callback>         
 *     } 
 * 
 * 
 * Cached results
 * --------------
 * Once your files are downloaded and all the callbacks have been fired, you can always retrieve your files data using 
 * the getResult() method, passing the file ID or an array of file IDs.
 * 
 * For each retrieved file, the following object is returned:
 * 
 *     {
 *         fileID: <ID of downloaded file>
 *         fileType: <Type of file (see 'File types' below for possible values)>
 *         fileData: <Appropriate DOM element or raw String object, depending on file type>,
 *         privateData: <Arbitrary data provided in the manifest for this file>   
 *     }
 * 
 * 
 * File Types
 * ==========
 * PreloadJS will try to guess the type of the files you download from their filename extension. Depending on this type,
 * appropriate DOM elements might be created automatically once the file is downloaded. 
 * 
 * The following types are known:
 * 
 *       -------------------------------------------------------------------------------------------------
 *      | TYPE       | EXTENSIONS           | RESULTING "DATA"                                            |
 *      |------------|----------------------|-------------------------------------------------------------|
 *      | image      | jpeg, jpg, gif, png  | IMG tag                                                     |
 *      | xml        | xml                  | Document object, parsed using DOMParser / Microsoft.XMLDOM  |
 *      | json       | json                 | Raw string                                                  |
 *      | svg        | svg                  | OBJECT tag with type="image/svg+xml"                        |
 *      | sound      | ogg, mp3, wav        | AUDIO tag with type="audio/ogg" (?!)                        |
 *      | javascript | js                   | SCRIPT tag with type="text/javascript"                      |
 *      | css        | css                  | LINK tag with type="text/css" and rel="Stylesheet"          |
 *      | text       | anything else        | Raw string                                                  |
 *       -------------------------------------------------------------------------------------------------
 * 
 * As mentioned above, the type guessing can be overridden by setting the 'type' property of your files in your manifest.
 * This can be useful when you are loading an image generated by a PHP script, for instance.
 * 
 * 
 * Callbacks
 * =========
 * 
 * The FileLoader class uses $.Deferred to provide callbacks support for the following events:
 * 
 *       --------------------------------------------------------------------------------------------
 *      | EVENT                               |    USING    | eventType (if applicable)              |
 *      |-------------------------------------|-------------|----------------------------------------|
 *      | Download start                      | .progress() | FileLoader.EVENT_TYPE.start_loading    | 
 *      | Per-file download progress          | .progress() | FileLoader.EVENT_TYPE.file_progress    |
 *      | Batch overall download progress     | .progress() | FileLoader.EVENT_TYPE.overall_progress |
 *      | Download/other error                | .fail()     | -                                      |
 *      | File download completion            | .progress() | FileLoader.EVENT_TYPE.file_loaded      |
 *      | Full batch completion               | .done()     | -                                      |
 *       --------------------------------------------------------------------------------------------
 *       
 * The previous table's 'USING' column gives the Deferred method to use to add callbacks to the FileLoader instance; the
 * 'eventType' column indicates which constant should be used to differentiate the different progress events.
 * 
 * Each callback, except the "Full batch completion" one, is passed an 'event' literal object as parameter, of which
 * properties vary from a callback to the other.
 * 
 * Download start
 * --------------
 * Triggered at the beginning of a file download (should be!)  
 * 
 *     {
 *         eventType: FileLoader.EVENT_TYPE.start_loading,
 *         fileID: <ID of file being downloaded>   
 *     }
 * 
 * /!\ Due to current PreloadJS behavior and until it is fixed, this callback will be called only at the start of a batch
 * download and fileID will be undefined.
 * 
 * 
 * File download progress
 * ----------------------
 * Triggered during file download progression
 * 
 *     {
 *         eventType: FileLoader.EVENT_TYPE.file_progress,
 *         progress: <Current download completion (a Number ranging from 0.0 to 1.0)>,
 *         fileID: <ID of file being downloaded>   
 *     }
 * 
 * 
 * Batch overall progress
 * ----------------------
 * Triggered during batch download progression
 * 
 *     { 
 *         eventType: FileLoader.EVENT_TYPE.overall_progress,
 *         progress: <Current overall download completion (a Number ranging from 0.0 to 1.0)>    
 *     }
 * 
 * Download/other error
 * --------------------
 * Triggered on various errors
 * 
 *     {
 *         error: <Error message>,
 *         fileID: <ID of file causing the error>
 *     }
 * 
 * Note that both properties might be empty/undefined depending on the error
 * 
 * 
 * File download completion
 * ------------------------
 * Triggered when a file has been fully downloaded
 * 
 *     {
 *         eventType: FileLoader.EVENT_TYPE.file_loaded,
 *         fileID: <ID of downloaded file>
 *         fileType: <Type of file (see 'File types' above for possible values)>
 *         fileData: <Appropriate DOM element or raw String object, depending on file type>,
 *         privateData: <Arbitrary data provided in the manifest for this file>   
 *     }
 * 
 */

this.playground = this.playground || {};

(function($) {
	(function() {

		var FileLoader = function(manifest, maxConnections) {
			this.initialize(manifest, maxConnections);
		};
		var p = FileLoader.prototype;

		// CONSTANTS
		FileLoader.EVENT_TYPE = {
			start_loading   : "start_loading",
			overall_progress: "overall_progress",
			file_progress   : "file_progress",
			file_loaded     : "file_loaded"
		};

		// PRIVATE PROPERTIES
		p._maxConnections   = 1;
		p._preloader        = null;
		p._manifest         = null;
		p._deferred         = null;
		p._loaded           = false;

		// CONSTRUCTOR
		p.initialize = function(manifest, maxConnections) {
			// Save files manifest & maxConnections
			this._manifest = manifest || [];
			this._maxConnections = maxConnections || this._maxConnections;

			// Configure PreloadJS instance
			var preloader = this._preloader = new createjs.PreloadJS(true);

			// Set callbacks with 'this' bound to our own instance
			preloader.onLoadStart       = playground.proxy(this._handleLoadStart, this);
			preloader.onProgress        = playground.proxy(this._handleOverallProgress, this);
			preloader.onFileProgress    = playground.proxy(this._handleFileProgress, this);
			preloader.onError           = playground.proxy(this._handleError, this);
			preloader.onFileLoad        = playground.proxy(this._handleFileLoad, this);
			preloader.onComplete        = playground.proxy(this._handleComplete, this);

			// Create a new Deferred and call promise(this) so that our instance acts as a Promise object for this deferred
			this._deferred = $.Deferred();
			this._deferred.promise(this);
		};

		// PUBLIC METHODS
		p.load = function() {
			if(this._loaded) return;
			this._preloader.loadManifest(this._manifest);

			// Set the maxConnections property here to work around a bug in PreloadJS
			// (See https://github.com/CreateJS/PreloadJS/issues/18#issuecomment-8215947 &
			//      https://github.com/CreateJS/PreloadJS/issues/5#issuecomment-8215603)
			this._preloader.setMaxConnections(this._maxConnections);
		};

		p.loading = function() {
			return this._deferred.state() === "pending";
		}

		p.getResult = function(ids) {
			var wasArray = true;
			if(!(ids instanceof Array))
			{
				wasArray = false;
				ids = [ids];
			}

			var results = [];
			$.each(ids, function(idx, id) {
				var result = this._preloader.getResult(id);
				if(result)
				{
					results.push(this._fileDescriptor(result));
				}
			});

			return wasArray ? results : results.shift();
		};


		// PRIVATE METHODS
		p._fileDescriptor = function(preloadjsResult) {
			return {
				fileID: preloadjsResult.id,
				fileType: preloadjsResult.type,
				fileData: preloadjsResult.result,
				privateData: preloadjsResult.data
			};
		};

		p._handleLoadStart = function(event) {
			this._deferred.notify({
				eventType: FileLoader.EVENT_TYPE.start_loading,
				fileID: event.id
			});
		};

		p._handleOverallProgress = function(event) {
			this._deferred.notify({
				eventType: FileLoader.EVENT_TYPE.overall_progress,
				progress: event.target.progress
			});

			this._loaded = (event.target.progress === 1.0);
		};

		p._handleFileProgress = function(event) {
			this._deferred.notify({
				eventType: FileLoader.EVENT_TYPE.file_progress,
				progress: event.progress,
				fileID: event.id
			});
		};

		p._handleError = function(event) {
			this._deferred.reject({
				error: event.text || "",
				fileID: event.id
			});
		};

		p._handleFileLoad = function(event) {
			var fileDesc = this._fileDescriptor(event);
			fileDesc.eventType = FileLoader.EVENT_TYPE.file_loaded;
			this._deferred.notify(fileDesc);
		};

		p._handleComplete = function(event) {
			this._loaded = true;
			this._deferred.resolve();
		};


		/* FileLoader is namespaced into playground */
		playground.FileLoader = FileLoader;
	}());
	
}(jQuery));

